---------------------------Метод грубой силы.-----------------------------------

Представляет стобой прямой подход решения задачи, он обычно основан на
формулировки задачи. Например Алгоритм умножения матриц, оснванный на
определении, поиск НОД. Может применяться для решения задач небольшой
размерности или в случаях требуется решить несколько экземпляров задачи, а
разработка более эффективных алгоритмов требует дополнительных затрат.

Пример: сортировка выбором -----------------------------------------------------

Ищем минимальный элемент, меняем его с первым, затем минимальный, начиная со
второго и меняем со вторым итд

for i in range(0, n - 2):
	min = i
	for j in range(i + 1, n - 1):
		if a[j] < a[min]:
			min = j
	swap(a[i], a[min])

Пример: сортировка пузырьком ---------------------------------------------------

for i in range(0, n - 2):
	for j in range(0, n - 2 -i):
		if (a[j + 1] < a[j]):
			swap(a[j + 1], a[j])

В случае модифицированного алгоритма пузыркорьковой сортировкиес (если не сделано
ни одного обмена алгоритм прекращает работу) эффективность будет зависеть не
только от размера входных данных. В наилучшем случае, когда массив почти
полностью отсортрован достаточно будет одного прохода, то есть линейная
эффективность. В наихудшем и среднем случаях эффективность все равно
квадратичная.

Алгоритм Поиск подстрок.--------------------------------------------------------

Tекст T представляющйи символьную строку длинной n
и шаблон P c длинной m
требуется найти в тексте T подстроку с шаблоном P - индекс i

T - n
P - m

t[0] t[1] t[2] t[3] t[4] t[5] ... t[i] ... t[i + j] ... t[i + m] ... t[n]

for i in range(0, n - m):
	j = 0
	while (j < m and p[j] == t[i + j]):
		j = j + 1
	if j = m
		return i
return -1

Поиск пары ближайших точек------------------------------------------------------

задано множество точек на плоскости.
найти пару, расстояние между которыми наименьшее

r = sqrt((x1 - x2)^2 + (y1 - y2)^2)

Алгоритм:

dmin = ∞
for i in range(1, n - 1):
	for j in range(i + 1, n):
		d = sqrt((x[i] - x[j])^2 + (y[i] - y[j])^2) # основная операция
		if d < dmin:
			dmin = d
			index1 = i
			index2 = j
return index1, index2

# можно без sqrt

Поиск выпуклой оболочки---------------------------------------------------------

Множество точек на плоскости(конечное или бесконечное) называют выпуклым,
если для любых двух точек из этого множества, отрезок, соединяющий эти точки
находится внутри этого множества.

Выпуклая оболочка множества их n точекнаплоскости - это наименьший по площади
многоугольник, который содержит все точки множества внутри или на границе.
Выпуклая оболочка множества точек S представляет собой наименбшее выпуклое
множество, содержащее S.

Th: Выпуклая облочка множества S состоящего из n > 2 точек н ележащих на одной
прямой представляет собой выпуклый сногоугольник с вершинами в некоторых точках
множества S

необходимо найти обходные точки множества в порядке обхода по или против часовой
стрелки.

--------------------------------------------------------------------------------

В задачах присутсвуют комбинаторные объекты часто приходится производить
генерацию этих комбинаторных объектов для того чтобы выбрать из них объект
обладающий некоторыми свойствами В случае с комбинаторными объетамимы получим
экспонециальную или факториальную сложность Исчерпывающий переюбор представляет
собой подход к комбинаторным задачам с позиции грубой силы

----------------------Задача комера и жора--------------------------------------

Города - известно расстояние между всеми парами городов Необходимо найти путь
минимальной длины включающий в себя все n городов по одному разу и начинающийся
и заканчивающийся в однои городе

Математическая постановка:
Дан неориентированный взвешанный полный граф содержащий n вершин Найти в нем
кратчайший гамельтонов цикл
цикл предаставляет собой перестановку вершин графа - городов

Задача о рюкзаке: --------------------------------------------------------------

n предметов с
весами: w1 w2 w3 ... wn
и ценностью: v1 v2 v3 ... v2
и рюкзак с подъёмностью: w
Подсчитать колличесво объектов в рюкзаке с макс суммарной ценностью

Задача о назначениях: ----------------------------------------------------------

Имеется n работников и m заданий. Известна стоимость выполнения i работником j
задания. Необходимо распределить задания между работниками, чтобы суммарные
затраты на все задания были минимальны.
Составляем матрицу работников и времени. Задача выделить один элемент на строку
и столбец

---------------------Метод декомпозиции-----------------------------------------
---------------------("разделяй и властвуй")------------------------------------

Экземпляр задачи разбивается на несколко меньших экземплуров той же задачи, в
идеале одинаковой размерности.

Тем же способом решабтся и остальные экземпляры задач(обычно рекурсивно)

При необходимости решение исходной задачи получается путём комбинации решений
меньших подзадач

Пусть есть экземпляр задачи n и его можно разьить на b > 1 подзадач. Из этих
подзадач решаются a >= 1 подзадач.

Общее время работы алгоритма, основанного на методе декомпозиции:

t(n) = a * T(n / b) + f(n) - обобщенное рекурентное кранение декомпозции.(*)

f(n) - функция учитывающая затраты времени на разделение задачи на подзадачи и
комбинировани решений подзадач.

Th: Если в рекурентном уравнении (*) f(n) = O(n^d) d >= 0

T(n) = O(n^d) , если a < b^d
T(n) = O(n^dlog(n)), a = b^d
T(n) = O(n^log(a, b)), a > b

-----------------------------Сортировка слиянием--------------------------------

def MergeSort(a[]):
	if (n > 1):
		copy a[0 .. n/2] in b
		copy a[n/2 .. n]] in c
		MergeSort(b)
		MergeSort(c)
		merge(b, c, a)

def merge(b, c, a):
	i, j, k = 0
	while (i in b and j in c):
		if b[i] < c[j]:
			a[k] = b[i]
			i = i + 1
		if  b[i] > c[j]:
			a[k] = c[j]
			j = j + 1
		k = k + 1
		if !b[i]:
			copy c[j..] in a
		else
			copy b[i..] in a

 = O(n * log(n))

--------------------Быстрая сортировка------------------------------------------

Разделяет элементы массива в соответствии с их значением. На каждрм шаге
алгоритма выполнятется перестановка элементов массива так, что для некоторой
позиции S - все элементы, не привышающие a[S] стоят левее a[s], а все больше
или равные - правее. В результате такого разбиения a[S] оказывается в
окончательной позиции в отсортированном массиве и подмассивы слева и справа от
a[S] модно сортировать независимо.

a[0] ... a[S - 1] a[S] a[S + 1] ... a[n]
(a[0] ... a[S - 1] < a[S]) && (a[S + 1] ... a[n] > a[S])

def quicksort(a[l..r])
	if l < r:
		s = Partition(a[l..r])
		quicksort(a[l..s-1])
		quicksort(a[s+1..r])

Разбиение осуществляется:
Выбираем элемент относительно которого будет производиться разбиение - опорный
элемент(любой элемент массива). Проходим Массив слева и справа. Двигаясь слева
пропускаем все элементы <= опорного(P), а двигаясь справа пропускаем >= опорного
В зависимости от того, пересекаются ли индексы сканирования, возможны три
ситуации:
	1: i(слева) < j(справа) - a[i] > p && a[j] < p - Меняем местами a[i] & a[j]
		и продолжаем движение
	2: i == j:	Меняем этот элемент и опорный (a[i] & p)
	3: i > j:	swap(p, a[j]) и разбиение массива продолжается

def Partition:
	p = a[l]
	i = l + 1
	j = r
	while (i <= j):
		while (a[i] < p):
			i = i + 1
		while (a[j] > p):
			j = j - 1
		swap(a[j], a[i])
	swap(a[j], a[l])
	return j

Колличесво для определения позиции разбиения равно n + 1 если i j пересекаются и
n если совпадают. Если все разбиения оказыватся в середине подмассива - 
реализуется лучший случай сортировки. Каждый раз массив делится пополам и 
решаются 2 задачи.

Наилучший случай:
с(1) = 0
c (n) = 2 * c(n/2) + n
c = n * log(n)

Наихудший случай реализуется тогда, когда опорный элемент оказывается первый 
или последний. При этом задача на каждом шаге уменьшается на 1.
с(n) = (n + 1) + n + (n - 1) + ... 1 = O(n^2)
Массив отсортирован в нужном порядке

Средний случай:
Предполодим, что разбиение может происходить в любой позиции с равной
вероятностью. 
с(n) = 1/n * (n + 1 + c(s) + c(s - 1 - s))
c(0) = 0
c(1) = 0
n * ln(n) = 1.38 * n * log2(n)

-----------------Бинарный поиск-------------------------------------------------

Применяется для поиска ключа в отсортированном массиве.

Алгоритм:
Выбирается средний элемент и сравнивается с ключом. Если элемент равен ключу,
то задача решена, если ключ больше, то ищем в правой части массива, иначе -
в левой.

def bs(a[0 .. n-1]):
	l = 0
	r = n-1
	while l <= r:
		m = (l + r) / 2
		if (a[m] = k)
			return m
		else if (a[m] > k):
			r = m - 1
		else:
			l = m + 1
	return n - 1

Худший случай - если искомого элемента нет
На каждом шаге массив делится пополам и после решается та же задаче с массивом 
размерностью в двое меньще предидущего.

c(n) = c(n/2) + 1
c(1) = 1
n = 2^k
c(n) = c(2^k-1) + 2 = c(2^k-2) + 2 = c(2^k-i) + i = c(s^k-k) + k = c(2) + k = 
1 + log2(n)

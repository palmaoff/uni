---------------------------Метод грубой силы.-----------------------------------

Представляет стобой прямой подход решения задачи, он обычно основан на
формулировки задачи. Например Алгоритм умножения матриц, оснванный на
определении, поиск НОД.Может применяться для решения задач небольшой
размерности или в случаях требуется решить несколько экземпляров задачи, а
разработка более эффективных алгоритмов требует дополнительных затрат.

Пример: сортировка выбором -----------------------------------------------------

Ищем минимальный элемент, меняем его с первым, затем минимальный, начиная со
второго и меняем со вторым итд

for i in range(0, n - 2):
	min = j
	for j in range(i + 1, n - 1):
		if a[j] < a[min]:
			min = j
	swap(a[i], a[min])

Пример: сортировка пузырьком ---------------------------------------------------

for i in range(0, n - 2):
	for j in range(0, n - 2 -i):
		if (a[j + 1] < a[j]):
			swap(a[j + 1], a[j])

В случае модифицированного алгоритма пузырк=рьковой сортировкиес (ли не сделано
ни одного обмена алгоритм прекращает работу) эффективность будет зависеть не
только от размера входных данных. В наилучшем случае, когда массив почти
полностью отсортрован достаточно будет одного прохода, то есть линейная
эффективность. В наихудшем и среднем случаях эффективность все равно
квадратичная.

Алгоритм Поиск подстрок.--------------------------------------------------------

Tекст T представляющйи символьную строку длинной n
и шаблон P c длинной m
требуется найти в тексте T подстроку с шаблоном P - индекс i

T - n
P - m

t[0] t[1] t[2] t[3] t[4] t[5] ... t[i] ... t[i + j] ... t[i + m] ... t[n]

for i in range(0, n - m):
	j = 0
	while (j < m and p[j] = t[i + j]):
		j = j + 1
	if j = m
		return i
return -1

Поиск пары ближайших точек------------------------------------------------------

задано множество точек на плоскости.
найти пару, расстояние между которыми наименьшее

r = sqrt((x1 - x2)^2 + (y1 - y2)^2)

Алгоритм:

dmin = ∞
for i in range(1, n - 1):
	for j in range(i + 1, n):
		d = sqrt((x[i] - x[j])^2 + (y[i] - y[j])^2) # основная операция
		if d < dmin:
			dmin = d
			index1 = i
			index2 = j
return index1, index2

# можно без sqrt

Поиск выпуклой оболочки---------------------------------------------------------

Множество точек на плоскости(конечное или бесконечное) называют выпуклым,
если для любых двух точек из этого множества, отрезок, соединяющий эти точки
находится внутри этого множества.

Выпуклая оболочка множества их n точекнаплоскости - это наименьший по площади
многоугольник, который содержит все точки множества внутри или на границе.
Выпуклая оболочка множества точек S представляет собой наименбшее выпуклое
множество, содержащее S.

Th: Выпуклая облочка множества S состоящего из n > 2 точек н ележащих на одной
прямой представляет собой выпуклый сногоугольник с вершинами в некоторых точках
множества S

необходимо найти обходные точки множества в порядке обхода по или против часовой
стрелки.

--------------------------------------------------------------------------------

В задачах присутсвуют комбинаторные объекты часто приходится производить
генерацию этих комбинаторных объектов для того чтобы выбрать из них объект
обладающий некоторыми свойствами В случае с комбинаторными объетамимы получим
экспонециальную или факториальную сложность Исчерпывающий переюбор представляет
собой подход к комбинаторным задачам с позиции грубой силы

----------------------Задача комера и жора--------------------------------------

Города - известно расстояние между всеми парами городов Необходимо найти путь
минимальной длины включающий в себя все n городов по одному разу и начинающийся
и заканчивающийся в однои городе

Математическая постановка:
Дан неориентированный взвешанный полный граф содержащий n вершин Найти в нем
кратчайший гамельтонов цикл
цикл предаставляет собой перестановку вершин графа - городов

Задача о рюкзаке: --------------------------------------------------------------

n предметов с 
весами: w1 w2 w3 ... wn
и ценностью: v1 v2 v3 ... v2
и рюкзак с подъёмностью: w
Подсчитать колличесво объектов в рюкзаке с макс суммарной ценностью

Задача о назначениях: ----------------------------------------------------------

Имеется n работников и m заданий. Известна стоимость выполнения i работником j
задания. Необходимо распределить задания между работниками, чтобы суммарные
затраты на все задания были минимальны.
Составляем матрицу работников и времени. Задача выделить один элемент на строку
и столбец

---------------------Метод декомпозиции-----------------------------------------
---------------------("разделяй и властвуй")------------------------------------

Экземпляр задачи разбивается на несколко меньших экземплуров той же задачи, в
идеале одинаковой размерности.

Тем же способом решабтся и остальные экземпляры задач(обычно рекурсивно)

При необходимости решение исходной задачи получается путём комбинации решений
меньших подзадач

Пусть есть экземпляр задачи n и его можно разьить на b > 1 подзадач. Из этих
подзадач решаются a >= 1 подзадач.

Общее время работы алгоритма, основанного на методе декомпозиции:

t(n) = a * T(n / b) + f(n) - обобщенное рекурентное кранение декомпозции.(*)

f(n) - функция учитывающая затраты времени на разделение задачи на подзадачи и
комбинировани решений подзадач.

Th: Если в рекурентно уравнении (*) f(n) = O(n^d) d >= 0

T(n) = O(n^d) , если a < b^d
T(n) = O(n^dlog(n)), a = b^d
T(n) = O(n^log(a, b)), a > b

-----------------------------Сортировка слиянием--------------------------------

def MergeSort(a[]):
	if (n > 1):
		copy a[0 .. n/2] in b
		copy a[n/2 .. n]] in c
		MergeSort(b)
		MergeSort(c)
		merge(b, c, a)


def merge(b, c, a):
	i, j, k = 0

	while (i in b and j in c):
		if b[i] < c[j]:
			a[k] = b[i]
			i = i + 1
		if  b[i] > c[j]:
			a[k] = c[j]
			j = j + 1
		k = k + 1
		if !b[i]:
			copy c[j..] in a
		else
			copy b[i..] in a

 = O(n * log(n))

 --------------------Быстрая сортировка-----------------------------------------


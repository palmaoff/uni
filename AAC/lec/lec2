---------------------Обход бинарного дерева-------------------------------------

Дерево - связный граф не содержащий циклов. Бинарным деревом называется
неориентированный граф степени вершин которго <= 2. Дерево - рекурсивная
структура. Наиболее важные алгоритмы бинарных деревьев - это обходы дерева.
Существует 2 вида обхода дерева: в глубину и в ширину. Алгоритм обхода в 
глубину построен на методе декомпозиции и имеет 3 варианта в зависимости от
порядка действий (префиксный, инфиксный, постфиксный).

Высота дерева - это длина самого длинного пути от корня до вершины.

def height(T):
	if !T:
		return -1
	else:
		return 1 + max(height(T.left), T.right)

------------------------Умножение больших чисел---------------------------------

23 14

(2 * 10 + 3) * (1 * 10 + 4)

Можно сократить колличество операций умножения добавив разность(сложение)

Считая основной операцией умножение выпишим рекрентное соотношение для
колличества умножений.

C(n) = 3 * C(n / 2) (better than n^2)

---------------------Нахождение двух ближайших точек----------------------------

----------------------Жадные алгоритмы------------------------------------------

Существуют задачи для которых последовательность локально-оптимальных выводов
приводит к оптимальному решению для любого экземпляра задачи. В некоторых
задачах это не так, но жадные аглоритмы могут применяться для нахождения
приближенного решения

	Алгоритм Прима:

Используется для нахождения минимального остовного дерева графа.

Остовное дерево графа представляет собой связанный ациклический подграф,
содержащий все вершины графа. Для полного графа содержащего n вершин
количество оставных деревьев равно n^(n - 2). Минимальное оставное дерево -
это оставное дерево имеющее минимальный суммарный вес ребер.

метод исчерпывающего перебора имеет эскмпонециальную сложность и задача 
генерации всех оставных деревьев является нетривиальной.

	Алгоритм Краскала

Алгоритм строит отстовное дерево. На промежуточных этапах не всегда связанный

Все ребра сортируются в порядке возрастания их весов. Начальный подграф пустой.
Добавляется очередное ребро их отсортированного списка ребер в список текущего
подграфа, если при этом не создается циклов. В противном случае ребро
пропускается и список просматривается далее.

e = 0
counter = 0 # размер дерева
k = 0
while counter < |v| - 1:
	k += 1
	if e + e(i,k) - ациклический граф
	counter += 1
return e

На каждой итерации проверяется не приветет ли добавление ребра к появлению 
цикла. Новый цикл обрахуется тогда и только тогда, когда новое ребро соединяет
2 вершины, принадлежащие одному и тому же связанному компоненту. Можно
рассматривать другую интерпритацию алгоритма. Все вершины по отдельности
представляют собой тривиальные деревья, а все вместе образуют лес. Конечный лес
представляет собой единое дерево, являющееся минимальным отстовным деревом.
На каждом шаге алгоритма выбирается очередное ребро и если вершины этого
ребра принадлежат разным деревьям, то они объединяются в одно, путем добавления
данного ребра. Алгоритмы которые эффективно выполняют данные действия называются
алгоритмами поиска объелинения. При применении этого алгоритма эффективность
алгоритма Краскала вычисляется сложностью алгоритма сортировки.

----------------------Непересекающиеся подмножества-----------------------------

Множество n элементов, необходимо разбить это множество на непересекающиеся 
подмножества s1, s2, ... sk.
Сначала иницилизируется набор из n элементных подмножеств, затем производится
последовательность операций объединения и поиска. То есть мы можем определить
абстрактную структуру данных, которая представляет собой набор непересекающихся
множеств и имеет 3 операции:
	melset(x) - создает одноэлементное множество из эл x. Данная операция
		применяется 1 раз, при инициализации набора множеств
	find(x) - находит подмножество, содержащее элемент x
	union(x, y) - находит подмножество sx & sy, содержащие элементы x & y 
		соответсвенно, строит объедининие подмножеств sx & sy и добавляет
		объединение вместо sx & sy
